import pytest
from fastapi import FastAPI
from fastapi.testclient import TestClient
import httpx
import logging
from unittest.mock import patch, MagicMock

# Import the router and the function from your bank_router.py
# Make sure your bank_router.py is accessible, e.g., in the same directory or properly installed
from bank_router import bank_router, generate_bank_url, BANK_CONFIGS

# Configure the root logger for testing to capture messages
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
test_logger = logging.getLogger('bank_router') # Get the logger instance used in bank_router.py

# Create a dummy FastAPI app to include your router for testing
# This is a minimal setup just for the TestClient
app = FastAPI()
app.include_router(bank_router)
client = TestClient(app)

# --- Tests for generate_bank_url function ---

@pytest.mark.parametrize(
    "bank_index, expected_url_segment, expected_next_index",
    [
        (0, "001a--test-002a-validate003a--uat-004a", 1), # bank040
        (1, "001b--test-002b-validate003b--uat-004b", 2), # bank002
        (2, "001c--test-002c-validate003c--uat-004c", 3), # bank003
        (3, "001d--test-002d-validate003d--uat-004d", 0), # bank004 (wraps around)
    ]
)
def test_generate_bank_url_success(bank_index, expected_url_segment, expected_next_index):
    """Tests if generate_bank_url produces the correct URL and next index."""
    base_url_template = "https://myrul-{var1}--test-{var2}-validate{var3}--uat-{var4}"
    
    updated_url, next_index = generate_bank_url(base_url_template, bank_index)
    
    assert expected_url_segment in updated_url
    assert updated_url.startswith("https://myrul-")
    assert updated_url.endswith(expected_url_segment) # Simplified check for brevity
    assert next_index == expected_next_index

def test_generate_bank_url_invalid_index():
    """Tests if generate_bank_url raises IndexError for invalid indices."""
    base_url_template = "https://myrul-{var1}--test-{var2}-validate{var3}--uat-{var4}"
    
    with pytest.raises(IndexError, match="Bank index -1 is out of range"):
        generate_bank_url(base_url_template, -1)
    
    num_banks = len(BANK_CONFIGS)
    with pytest.raises(IndexError, match=f"Bank index {num_banks} is out of range"):
        generate_bank_url(base_url_template, num_banks)


# --- Tests for get_data_with_bank_retries endpoint ---

@pytest.fixture(autouse=True)
def _mock_logger_reset():
    """Fixture to ensure logger mocks are clean for each test."""
    with patch('bank_router.logger', spec=True) as mock_logger:
        yield mock_logger

@pytest.fixture
def mock_httpx_responses(httpx_mock):
    """A helper fixture to simplify mocking httpx requests."""
    return httpx_mock

def test_get_data_success_first_bank(_mock_logger_reset, mock_httpx_responses):
    """Test case: First bank returns data successfully."""
    mock_httpx_responses.add(
        httpx.GET,
        "https://myrul-001a--test-002a-validate003a--uat-004a",
        json=[{"id": 1, "data": "bank040_data"}],
        status_code=200
    )

    response = client.get("/bank/my-data")

    assert response.status_code == 200
    assert response.json() == [{"id": 1, "data": "bank040_data", "processed_status": "processed", "some_new_field": "value_from_001a"}]
    
    _mock_logger_reset.info.assert_any_call(
        "Attempt 1/4 using bank040 URL: https://myrul-001a--test-002a-validate003a--uat-004a"
    )
    _mock_logger_reset.info.assert_any_call(
        "Found records on attempt 1 with bank040."
    )
    _mock_logger_reset.info.assert_any_call("Starting data massaging...")
    _mock_logger_reset.info.assert_any_call("Data massaging complete. Returning processed data.")
    assert mock_httpx_responses.get_request().url == "https://myrul-001a--test-002a-validate003a--uat-004a"


def test_get_data_retry_success_second_bank(_mock_logger_reset, mock_httpx_responses):
    """Test case: First bank returns empty, second bank returns data."""
    # Mock first bank (bank040) to return empty list
    mock_httpx_responses.add(
        httpx.GET,
        "https://myrul-001a--test-002a-validate003a--uat-004a",
        json=[],
        status_code=200
    )
    # Mock second bank (bank002) to return data
    mock_httpx_responses.add(
        httpx.GET,
        "https://myrul-001b--test-002b-validate003b--uat-004b",
        json=[{"id": 2, "data": "bank002_data"}],
        status_code=200
    )

    response = client.get("/bank/my-data")

    assert response.status_code == 200
    assert response.json() == [{"id": 2, "data": "bank002_data", "processed_status": "processed", "some_new_field": "value_from_001b"}]
    
    _mock_logger_reset.info.assert_any_call(
        "Attempt 1/4 using bank040 URL: https://myrul-001a--test-002a-validate003a--uat-004a"
    )
    _mock_logger_reset.info.assert_any_call(
        "Records are empty for bank040. Moving to next bank..."
    )
    _mock_logger_reset.info.assert_any_call(
        "Attempt 2/4 using bank002 URL: https://myrul-001b--test-002b-validate003b--uat-004b"
    )
    _mock_logger_reset.info.assert_any_call(
        "Found records on attempt 2 with bank002."
    )
    _mock_logger_reset.info.assert_any_call("Starting data massaging...")
    
    # Verify both requests were made
    requests = mock_httpx_responses.get_requests()
    assert len(requests) == 2
    assert requests[0].url == "https://myrul-001a--test-002a-validate003a--uat-004a"
    assert requests[1].url == "https://myrul-001b--test-002b-validate003b--uat-004b"


def test_get_data_all_banks_empty(_mock_logger_reset, mock_httpx_responses):
    """Test case: All banks return empty lists."""
    for i in range(len(BANK_CONFIGS)):
        bank_vars = BANK_CONFIGS[i]["vars"]
        url = "https://myrul-{var1}--test-{var2}-validate{var3}--uat-{var4}".format_map(bank_vars)
        mock_httpx_responses.add(httpx.GET, url, json=[], status_code=200)

    response = client.get("/bank/my-data")

    assert response.status_code == 200
    assert response.json() == [] # Expect an empty list if no data found
    
    # Verify logs for each empty attempt and the final message
    for i in range(len(BANK_CONFIGS)):
        _mock_logger_reset.info.assert_any_call(
            f"Records are empty for {BANK_CONFIGS[i]['name']}. Moving to next bank..."
        )
    _mock_logger_reset.info.assert_any_call(
        "All bank configurations tried, and no non-empty records were found."
    )
    assert len(mock_httpx_responses.get_requests()) == len(BANK_CONFIGS)


def test_get_data_all_banks_fail_http_error(_mock_logger_reset, mock_httpx_responses):
    """Test case: All banks fail with HTTP 500 errors."""
    for i in range(len(BANK_CONFIGS)):
        bank_vars = BANK_CONFIGS[i]["vars"]
        url = "https://myrul-{var1}--test-{var2}-validate{var3}--uat-{var4}".format_map(bank_vars)
        mock_httpx_responses.add(
            httpx.GET, url, content=f"Internal Server Error from {BANK_CONFIGS[i]['name']}", status_code=500
        )

    response = client.get("/bank/my-data")

    assert response.status_code == 500
    assert "Upstream service error after all retries" in response.json()["detail"]
    assert "Internal Server Error from bank004" in response.json()["detail"] # Last error detail

    # Verify logs for each warning and the final error
    for i in range(len(BANK_CONFIGS)):
        _mock_logger_reset.warning.assert_any_call(
            f"HTTP error (500) from {BANK_CONFIGS[i]['name']} for URL "
            f"https://myrul-{bank_vars['var1']}--test-{bank_vars['var2']}-validate{bank_vars['var3']}--uat-{bank_vars['var4']}: "
            f"Internal Server Error from {BANK_CONFIGS[i]['name']}"
        )
    _mock_logger_reset.error.assert_any_call("All retries failed with HTTP errors. Last error: Internal Server Error from bank004")
    assert len(mock_httpx_responses.get_requests()) == len(BANK_CONFIGS)


def test_get_data_mixed_http_error_and_success(_mock_logger_reset, mock_httpx_responses):
    """Test case: First bank fails with HTTP 404, second succeeds."""
    # Bank 040 fails with 404
    mock_httpx_responses.add(
        httpx.GET,
        "https://myrul-001a--test-002a-validate003a--uat-004a",
        content="Not Found",
        status_code=404
    )
    # Bank 002 succeeds with data
    mock_httpx_responses.add(
        httpx.GET,
        "https://myrul-001b--test-002b-validate003b--uat-004b",
        json=[{"item": "from_bank002"}],
        status_code=200
    )

    response = client.get("/bank/my-data")

    assert response.status_code == 200
    assert response.json() == [{"item": "from_bank002", "processed_status": "processed", "some_new_field": "value_from_001b"}]

    _mock_logger_reset.warning.assert_any_call(
        "HTTP error (404) from bank040 for URL "
        "https://myrul-001a--test-002a-validate003a--uat-004a: Not Found"
    )
    _mock_logger_reset.info.assert_any_call(
        "Found records on attempt 2 with bank002."
    )
    assert len(mock_httpx_responses.get_requests()) == 2


def test_get_data_unexpected_exception(_mock_logger_reset, mock_httpx_responses):
    """Test case: First bank raises an unexpected exception (e.g., connection error)."""
    # Mock httpx to raise a generic exception for the first call
    mock_httpx_responses.add(
        httpx.GET,
        "https://myrul-001a--test-002a-validate003a--uat-004a",
        json={"error": "simulated connection error"},
        status_code=200, # Status 200, but we'll mock the exception
        exc=httpx.ConnectError("Simulated connection error")
    )
    # Ensure a subsequent bank could succeed if the retry logic wasn't strict on general exceptions
    mock_httpx_responses.add(
        httpx.GET,
        "https://myrul-001b--test-002b-validate003b--uat-004b",
        json=[{"item": "from_bank002"}],
        status_code=200
    )


    response = client.get("/bank/my-data")

    assert response.status_code == 200 # It should retry and succeed with the second bank
    assert response.json() == [{"item": "from_bank002", "processed_status": "processed", "some_new_field": "value_from_001b"}]
    
    _mock_logger_reset.error.assert_any_call(
        "Unexpected exception during call to bank040 for URL "
        "https://myrul-001a--test-002a-validate003a--uat-004a: Simulated connection error",
        exc_info=True # Assert that exc_info was passed
    )
    _mock_logger_reset.warning.assert_any_call(
        "An unexpected error occurred for bank040. Retrying with next bank..."
    )
    _mock_logger_reset.info.assert_any_call(
        "Found records on attempt 2 with bank002."
    )
    assert len(mock_httpx_responses.get_requests()) == 2


def test_get_data_unexpected_exception_all_banks_fail(_mock_logger_reset, mock_httpx_responses):
    """Test case: All banks raise unexpected exceptions."""
    for i in range(len(BANK_CONFIGS)):
        bank_vars = BANK_CONFIGS[i]["vars"]
        url = "https://myrul-{var1}--test-{var2}-validate{var3}--uat-{var4}".format_map(bank_vars)
        mock_httpx_responses.add(
            httpx.GET, url, exc=httpx.ConnectError(f"Simulated connection error {i}")
        )

    response = client.get("/bank/my-data")

    assert response.status_code == 500
    assert "An unexpected error occurred after all retries" in response.json()["detail"]
    assert "Simulated connection error 3" in response.json()["detail"] # Last error

    for i in range(len(BANK_CONFIGS)):
        _mock_logger_reset.error.assert_any_call(
            f"Unexpected exception during call to {BANK_CONFIGS[i]['name']} for URL "
            f"https://myrul-{bank_vars['var1']}--test-{bank_vars['var2']}-validate{bank_vars['var3']}--uat-{bank_vars['var4']}: "
            f"Simulated connection error {i}",
            exc_info=True
        )
    assert len(mock_httpx_responses.get_requests()) == len(BANK_CONFIGS)


def test_get_data_with_request_headers(_mock_logger_reset, mock_httpx_responses):
    """Ensure request headers are passed to httpx."""
    mock_httpx_responses.add(
        httpx.GET,
        "https://myrul-001a--test-002a-validate003a--uat-004a",
        json=[{"id": 1}],
        status_code=200
    )

    response = client.get("/bank/my-data", headers={"X-Custom-Header": "my-value"})

    assert response.status_code == 200
    request = mock_httpx_responses.get_request()
    assert request.headers["x-custom-header"] == "my-value" # Headers are lowercased by httpx/http protocols

def test_data_massaging_logic_for_string_items(_mock_logger_reset, mock_httpx_responses):
    """Test that the massaging logic correctly handles string items."""
    mock_httpx_responses.add(
        httpx.GET,
        "https://myrul-001a--test-002a-validate003a--uat-004a",
        json=["item1", "item2", "item3"],
        status_code=200
    )

    response = client.get("/bank/my-data")

    assert response.status_code == 200
    # For string items, the fake logic converts them to uppercase
    assert response.json() == ["ITEM1", "ITEM2", "ITEM3"]

def test_data_massaging_logic_for_mixed_items(_mock_logger_reset, mock_httpx_responses):
    """Test that the massaging logic correctly handles mixed item types."""
    mock_httpx_responses.add(
        httpx.GET,
        "https://myrul-001a--test-002a-validate003a--uat-004a",
        json=[{"name": "test"}, "hello", 123],
        status_code=200
    )

    response = client.get("/bank/my-data")

    assert response.status_code == 200
    expected_response = [
        {"name": "test", "processed_status": "processed", "some_new_field": "value_from_unknown"}, # var1 not in dict, so 'unknown'
        "HELLO",
        123
    ]
    assert response.json() == expected_response
