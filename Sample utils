# tests/conftest.py
import json
import importlib
import pytest
from fastapi import FastAPI

@pytest.fixture
def temp_mapping_file(tmp_path):
    """Create a temporary mapping.json file with sample keys/values."""
    mapping = {
        "app1 url details": "url1",
        "app2 url details": "url2",
        "app3 url details": "url3",
    }
    f = tmp_path / "mapping.json"
    f.write_text(json.dumps(mapping))
    return str(f)

@pytest.fixture
def client(monkeypatch, temp_mapping_file):
    """
    Patch config.URL_MAPPING to our temp file before importing
    routes.fuzzy_logic, then mount router in a test app.
    """
    import config
    monkeypatch.setattr(config, "URL_MAPPING", temp_mapping_file)

    # Force reload of module so it reads new config
    module_name = "routes.fuzzy_logic"
    if module_name in importlib.sys.modules:
        importlib.reload(importlib.import_module(module_name))
    else:
        importlib.import_module(module_name)
    routes_fuzzy = importlib.import_module(module_name)

    # Build FastAPI app
    from starlette.testclient import TestClient
    app = FastAPI()
    app.include_router(routes_fuzzy.router)
    return TestClient(app)


# tests/test_fuzzy_logic.py
import importlib
from unittest.mock import AsyncMock, patch

def test_fuzzy_logic_response_happy_path(client):
    routes_fuzzy = importlib.import_module("routes.fuzzy_logic")

    # Mock external deps
    with patch.object(routes_fuzzy.time, "perf_counter", side_effect=[1.0, 1.005]), \
         patch.object(routes_fuzzy, "match_api_endpoint_async", new_callable=AsyncMock) as mock_match, \
         patch.object(routes_fuzzy, "get_logger") as mock_logger:

        mock_logger.return_value = object()
        mock_match.return_value = {
            "keyword": "app1 url details",
            "api_endpoint": "http://mocked/api/app1"
        }

        payload = {"step": "Given i fetch app1 url details"}
        resp = client.post("/fuzzy_logic_response", json=payload)
        assert resp.status_code == 200

        body = resp.json()
        assert body["logic"] == "fuzzy logic"
        # 5 ms elapsed
        assert abs(body["elapsed_time_fuzzy in ms"] - 5.0) < 0.1
        assert body["matched_keyword"] == "app1 url details"
        assert body["api_endpoint"] == "http://mocked/api/app1"

        # Ensure static response block exists
        assert set(body["data"].keys()) == {"RESERVE", "GROWTH", "SPEND"}
        assert body["data"]["RESERVE"]["accountNumber"] == "0000000001"

        # Verify mock called with correct param
        mock_match.assert_awaited_once_with("Given i fetch app1 url details")


def test_import_initialization_and_vectorizer(client):
    """
    Ensures import-time code executed: vectorizer and keys built.
    """
    routes_fuzzy = importlib.import_module("routes.fuzzy_logic")
    assert hasattr(routes_fuzzy, "vectorizer")
    assert hasattr(routes_fuzzy, "keys")
    assert isinstance(routes_fuzzy.keys, list)
    assert len(routes_fuzzy.keys) > 0




pytest -q --disable-warnings \
  --cov=routes/fuzzy_logic.py --cov-report=term-missing



#=======================================================================

# tests/test_routes.py

import pytest


def test_fuzzy_logic_response_success(client, monkeypatch):
    # Mock match_api_endpoint_async to avoid heavy logic
    async def fake_match(step: str):
        return {"keyword": "app1 url details", "api_endpoint": "url1"}

    import routes.fuzzy_logic as fuzzy_logic
    monkeypatch.setattr(fuzzy_logic, "match_api_endpoint_async", fake_match)

    payload = {"step": "get account"}
    response = client.post("/fuzzy_logic_response", json=payload)

    assert response.status_code == 200
    data = response.json()
    assert data["logic"] == "fuzzy logic"
    assert "elapsed_time_fuzzy in ms" in data
    assert data["matched_keyword"] == "app1 url details"
    assert data["api_endpoint"] == "url1"
    assert "RESERVE" in data["data"]


def test_nlp_logic_response_success(client):
    payload = {"step": "app2 url"}  # should fuzzy match "app2 url details"
    response = client.post("/nlp_logic_response", json=payload)

    assert response.status_code == 200
    data = response.json()
    assert data["logic"] == "NLP logic"
    assert "elapsed_time_nlp in ms" in data
    assert data["matched_keyword"] == "app2 url details"
    assert data["api_endpoint"] == "url2"
    assert "RESERVE" in data["data"]


def test_fuzzy_logic_response_invalid_payload(client):
    # Missing required field "step"
    response = client.post("/fuzzy_logic_response", json={"wrong": "data"})
    assert response.status_code == 422


def test_nlp_logic_response_invalid_payload(client):
    # Missing required field "step"
    response = client.post("/nlp_logic_response", json={"foo": "bar"})
    assert response.status_code == 422


#tests/conftest.py

import pytest
import json
import importlib
from fastapi.testclient import TestClient
import config


@pytest.fixture(scope="session")
def client(tmp_path_factory, monkeypatch):
    # Create a temporary mapping.json for tests
    tmp_dir = tmp_path_factory.mktemp("data")
    mapping_file = tmp_dir / "mapping.json"
    mapping = {
        "app1 url details": "url1",
        "app2 url details": "url2",
        "app3 url details": "url3"
    }
    mapping_file.write_text(json.dumps(mapping))

    # Monkeypatch config.URL_MAPPING to point at test file
    monkeypatch.setattr(config, "URL_MAPPING", str(mapping_file))

    # Reload dev module so it picks up test mapping.json
    import routes.fuzzy_logic as fuzzy_logic
    importlib.reload(fuzzy_logic)

    # Build FastAPI test app
    from fastapi import FastAPI
    app = FastAPI()
    app.include_router(fuzzy_logic.router)

    return TestClient(app)






