import json
import logging
from pathlib import Path
from typing import Dict

logger = logging.getLogger(__name__)

class MappingLoader:
    """
    Loads and manages multiple mapping JSON files.
    Each file has structure { "fuzzy_key": "endpoint_url" }.
    """

    def __init__(self, base_path: str = "data"):
        self.base_path = Path(base_path)
        self.mappings: Dict[str, Dict[str, str]] = {}

    def load_mapping(self, name: str, filename: str) -> None:
        """Load a mapping JSON file into memory under a given name."""
        file_path = self.base_path / filename
        if not file_path.exists():
            logger.warning(f"Mapping file {file_path} not found.")
            self.mappings[name] = {}
            return

        try:
            with file_path.open("r") as f:
                self.mappings[name] = json.load(f)
                logger.info(f"Loaded mapping file {filename} into scope '{name}'")
        except Exception as e:
            logger.error(f"Failed to load {filename}: {e}")
            self.mappings[name] = {}

    def get_mapping(self, name: str) -> Dict[str, str]:
        """Retrieve the mapping dictionary by scope name (legacy, mod, reserve)."""
        return self.mappings.get(name, {})






from rapidfuzz import process
from typing import Dict, Optional, Tuple

class FuzzyMatcher:
    """
    Fuzzy matches a given query against a mapping dictionary (key -> URL).
    """

    def __init__(self, mapping: Dict[str, str]):
        self.mapping = mapping

    def match(self, query: str, score_cutoff: int = 70) -> Optional[Tuple[str, str, int]]:
        """
        Match query string against mapping keys.

        Returns:
            (best_key, endpoint_url, score) if match found, else None.
        """
        if not self.mapping:
            return None

        best_match = process.extractOne(query, self.mapping.keys(), score_cutoff=score_cutoff)
        if best_match:
            key, score, _ = best_match
            return key, self.mapping[key], score
        return None






import logging
from fastapi import APIRouter, Request, HTTPException, Query
from utils.mapping_loader import MappingLoader
from utils.fuzzy_matcher import FuzzyMatcher
import httpx

logger = logging.getLogger(__name__)

account_router = APIRouter(
    prefix="/account",
    tags=["account"],
    responses={404: {"description": "Not found"}},
)

# --- Initialize mappings ---
loader = MappingLoader(base_path="data")
loader.load_mapping("legacy", "mapping_legacy.json")
loader.load_mapping("mod", "mapping_mod.json")
loader.load_mapping("reserve", "mapping_reserve.json")

# --- Example bank configs for retry ---
BANK_CONFIGS = [
    {"name": "bank040", "vars": {"var1": "001a", "var2": "002a"}},
    {"name": "bank002", "vars": {"var1": "001b", "var2": "002b"}},
    {"name": "bank003", "vars": {"var1": "001c", "var2": "002c"}},
]

def generate_bank_url(base_url_template: str, bank_index: int) -> str:
    """Apply bank-specific variables to a base URL template."""
    bank_vars = BANK_CONFIGS[bank_index]["vars"]
    return base_url_template.format_map(bank_vars)


@account_router.get("/getaccount")
async def get_account(
    request: Request,
    query: str = Query(..., description="Fuzzy query (e.g., Gherkin step)"),
    scope: str = Query("legacy", description="Scope to use: legacy, mod, reserve"),
):
    """
    Fuzzy match query against scoped JSON file (single endpoint).
    Then apply bank retry logic to fetch data.
    """

    mapping = loader.get_mapping(scope)
    if not mapping:
        raise HTTPException(status_code=404, detail=f"No mapping found for scope '{scope}'")

    matcher = FuzzyMatcher(mapping)
    match_result = matcher.match(query)

    if not match_result:
        raise HTTPException(status_code=404, detail=f"No fuzzy match found for '{query}' in scope '{scope}'")

    matched_key, base_url_template, score = match_result
    logger.info(f"Matched query '{query}' -> '{matched_key}' -> template {base_url_template} (score={score})")

    headers = dict(request.headers.items())
    records = []
    attempts = 0
    max_attempts = len(BANK_CONFIGS)

    async with httpx.AsyncClient(timeout=30.0) as client:
        current_bank_idx = 0
        while attempts < max_attempts:
            current_url = generate_bank_url(base_url_template, current_bank_idx)
            logger.info(f"Attempt {attempts+1}/{max_attempts} using {BANK_CONFIGS[current_bank_idx]['name']} -> {current_url}")

            try:
                response = await client.get(current_url, headers=headers)
                response.raise_for_status()
                data = response.json()

                if data and data != []:
                    return {
                        "matched_key": matched_key,
                        "scope": scope,
                        "bank": BANK_CONFIGS[current_bank_idx]["name"],
                        "endpoint": current_url,
                        "score": score,
                        "data": data,
                    }

                logger.warning(f"Empty response from {current_url}, trying next...")

            except Exception as e:
                logger.error(f"Error on {BANK_CONFIGS[current_bank_idx]['name']} URL {current_url}: {e}")

            finally:
                current_bank_idx = (current_bank_idx + 1) % max_attempts
                attempts += 1

    raise HTTPException(status_code=404, detail="All retries exhausted, no data found")
